

Project moltrack {
    database_type: 'PostgreSQL'
    Note: 'Converted from schema.sql'
}

TablePartial created_updated_details {
    created_at timestamp [default: `CURRENT_TIMESTAMP`]
    updated_at timestamp [default: `CURRENT_TIMESTAMP`]
    created_by uuid [not null, ref: > Users.id]
    updated_by uuid [not null, ref: > Users.id]   

}

TablePartial base {
    id serial [pk]
    ~created_updated_details
}

TablePartial soft_delete_template {
    is_archived boolean [default: false]
    deleted_at timestamp [default: `CURRENT_TIMESTAMP`]
    deleted_by uuid [not null, ref: > Users.id]
}

Table moltrack.users as Users {
    id uuid [pk, not null]
    email text [not null, unique]
    first_name text [not null]
    last_name text [not null]
    has_password boolean [not null]
    is_active boolean [not null, default: false]
    is_service_account boolean [not null, default: false]
    ~created_updated_details

    indexes {
        email [unique, note: 'this may be a risk for external users over time']
    }

    Note: '''
    for MVP, just a single global user will be configured
    '''
}

Table moltrack.settings as Settings {
    id serial [pk]
    name text [not null]
    value text [not null]
    description text [not null]
 
    Note: '''
        This table is used to store configuration settings for the application.
        examples include:
        - compound standardization rules
        - compound uniqueness rules
        - compound identification rules and synonym generation rules
        - batch identification rules and synonym generation rules
        I suspect that there should be some more structure to this table, but for MVP, this will be used to store the rules for the global user.
    '''
}

Table moltrack.compounds as Compounds {
    ~base
    ~created_updated_details
    canonical_smiles text [not null, note: 'RDKit canonical SMILES']
    original_molfile text [note: 'as sketched by the chemist']
    molregno int [not null, unique, note: 'generated by the system based on business rules']
    inchi text [not null, note: 'IUPAC InChI']
    inchikey text [not null, unique, note: 'IUPAC InChIKey']
    formula text [not null]
    hash_mol uuid [not null, unique]
    hash_tautomer uuid [not null, unique]
    hash_canonical_smiles uuid [not null, unique]
    hash_no_stereo_smiles uuid [not null, unique]
    hash_no_stereo_tautomer uuid [not null, unique]
    ~soft_delete_template

    indexes {
        canonical_smiles
        inchi
        inchikey
        formula
        hash_mol [unique]
        hash_tautomer [unique]
        hash_canonical_smiles [unique]
        hash_no_stereo_smiles [unique]
        hash_no_stereo_tautomer [unique]
        molregno [unique]
    }

    Note: 'Compounds table - unique chemical structures'
}

Table moltrack.batches as Batches {
    ~base
    ~created_updated_details
    compound_id int [not null, ref: > Compounds.id]
    batch_regno text [not null]
    notes text
 
    indexes {
        compound_id
        batch_regno
    }
    Note: 'Batch is a physical sample of the compound (for instance synthesized or procured).'

}

Table moltrack.additions as Additions {
    ~base
    ~created_updated_details
    name text [not null, unique]
    description text
    code text
    is_active boolean [default: true]
    formula text
    molecular_weight real
    smiles text
    molfile text
    role text [note: "('SALT', 'SOLVATE', 'REAGENT', 'SOLVENT', 'OTHER')"]
    ~soft_delete_template

    indexes {
        name
        code
        formula
        role
    }

    Note: '''
    Additions table - for salts and solvates 
        Questions:
        - should we do check constraints for role?
    '''
}

Table moltrack.batch_additions as BatchAdditions {
    ~base
    ~created_updated_details
    batch_id int [not null, ref: > Batches.id]
    addition_id int [not null, ref: > Additions.id]
    addition_equivalent real [not null, default: 1.0, note: 'equivalent relative to parent batch']

    indexes {
        (batch_id, addition_id) [pk]
    }

    Note: '''
    Batch Addition table - This allows us to have multiple salt and solvates for a given batch'
    '''
}

Table moltrack.semantic_types as SemanticTypes {
    id serial [pk]
    name text [not null, note: 'e.g., "Molecule", "Cell", ...']
    description text

    Note: 'Explains the meaning of a scalar property.'
}

Table moltrack.properties as Properties {
    ~base
    ~created_updated_details
    name text [not null]
    value_type text [note: "('int', 'double', 'bool', 'datetime', 'string')"]
    semantic_type_id int [ref: > SemanticTypes.id]
    property_class text [note: "('CALCULATED', 'MEASURED', 'PREDICTED')"]
    unit text [note: 'future: unit should point to unit ontology']
    scope text [not null, note: 'check in ["BATCH","COMPOUND","ASSAY","SETTINGS"]']
    
    indexes {
        name
        value_type
        semantic_type_id
        property_class
    }

    Note: '''
    Properties table - for calculated and measured properties
    for validity checking should we have field to specify what entity this should be relevant
    
    value_type defines the colummn in the batch_details, assay_details and assay_results 
    tables that store the property value:
    * [value_num] for "int" and "double", 
    * [value_datetime] for "datetime", 
    * [value_uuid] for "uuid", 
    * [value_string] for "string"
    
    future: property should have ontology reference
    '''
}

Table moltrack.batch_details as BatchDetails {
    id serial [pk]
    batch_id int [not null, ref: > Batches.id]
    property_id int [not null, ref: > Properties.id]

    value_qualifier smallint [not null, default: 0,  note: 'SMALLINT, 0 for "=", 1 for "<", 2 for ">". Only used for numeric properties.']
    value_datetime timestamp [note: 'with time zone', default: `CURRENT_TIMESTAMP`]
    value_uuid uuid
    value_num float
    value_string text

    indexes {
        batch_id
        property_id
    }

    Note: '''
    Batch details table - for calculated and measured properties

    future: batch_details.value_string should have optional ontology reference
    '''
}

Table moltrack.synonym_types as SynonymTypes {
    ~base
    ~created_updated_details
    synonym_level text [not null, note: "('BATCH','COMPOUND')"]
    name text [not null, note: 'e.g., "CAS", "USAN", "INN", "tradename"']
    pattern text [not null, note: 'regex for identifier: CHEMBL.*']
    description text

    Note: '''
    Synonym types table - for batch and compound synonym types
    how to address combined uniqueness constraint
    '''
    indexes {
        (synonym_level, name) [unique]
    }
}

Table moltrack.compound_synonyms as CompoundSynonyms {
    ~base
    ~created_updated_details
    compound_id int [not null, ref: > Compounds.id]
    synonym_type_id int [not null, ref: > SynonymTypes.id]
    synonym_value text [not null]
    
    indexes {
        compound_id
        synonym_type_id
    }

    Note: 'Compound synonyms table - for compound synonym types: CAS, USAN, INN, tradename, source code'

}

Table moltrack.batch_synonyms as BatchSynonyms {
    ~base
    ~created_updated_details
    batch_id int [not null, ref: > Batches.id]
    synonym_type_id int [not null, ref: > SynonymTypes.id]
    synonym_value text [not null]

    indexes {
        batch_id
        synonym_type_id
    }

    Note: 'Batch synonyms table - for batch synonym types: CAS, USAN, INN, tradename, source code'
}

Table moltrack.compound_details as CompoundDetails {
    id serial [pk]
    ~created_updated_details
    compound_id int [not null, ref: > Compounds.id]
    property_id int [not null, ref: > Properties.id]

    value_datetime timestamp [note: 'with time zone', default: `CURRENT_TIMESTAMP`]
    value_uuid uuid
    value_num float
    value_string text

    indexes {
        compound_id
        property_id
    }

    Note: '''
    Compound details table - for calculated and measured properties
    future: compound_details.value_string should have optional ontology reference
    '''
}

Table moltrack.assay_types as AssayTypes {
    id serial [pk]
    ~created_updated_details
    name text [not null]
    description text

    Note: '''
    -- Assay types table - for assay types: kinase inhibition, cell viability, etc.
    -- this is the level for the protocol such as hepatocyte stability
    -- All of the required properties (see assay_type_properties) must be present in the assay results.
    
    '''
}

Table moltrack.assay_type_details as AssayTypeDetails {
    assay_type_id int [not null, ref: > AssayTypes.id]
    property_id int [not null, ref: > Properties.id]
    required boolean [not null, default: false]

    value_datetime timestamp [note: 'timestamp with time zone']
    value_uuid uuid
    value_num float
    value_string text

    Note: '''
    Assay type details table - example domain: in vivo, in vitro, etc., detection method: fluorescence, etc.
    PK: (assay_type_id, property_id)
    '''
    indexes {
        (assay_type_id, property_id) [unique]
    }
}

Table moltrack.assays as Assays {
    id serial [pk]
    assay_type_id int [not null, ref: > AssayTypes.id]
    name text [not null, note: 'e.g., "Kinase Inhibition Assay"']
    description text
    ~created_updated_details

    Note: '''
    Assays table - for assays: kinase inhibition, cell viability, etc.  
    This is the level of the experiment executed by the user.
    '''
}

Table moltrack.assay_details as AssayDetails {
    assay_id int [not null, ref: > Assays.id]
    property_id int [not null, ref: > Properties.id]

    value_datetime timestamp [note: 'with time zone', default: `CURRENT_TIMESTAMP`]
    value_uuid uuid
    value_num float
    value_string text

    Note: '''
    -- Assay details table - for calculated and measured properties
    -- This is the level of the experiment executed by the user.
    -- Details like assayer, eln reference, calculation date
    -- experimental conditions like temperature, time, cell lot, protein lot, etc.
    '''
    indexes {
        (assay_id, property_id) [unique]
    }
}

Table moltrack.assay_type_properties as AssayTypeProperties {
    Note: '''
        A set of measurement types for a given assay type.
        This will be used to validate the data submitted for an assay.
    '''
    assay_type_id int [not null, ref: > AssayTypes.id]
    property_id int [not null, ref: > Properties.id]
    required bool [not null, default: false, note: 'if true, must exist in submitted data for validation']

    indexes {
        (assay_type_id, property_id) [pk]
    } 
}

Table moltrack.assay_results as AssayResults {
    id serial [pk]
    batch_id int [not null, ref: > Batches.id]
    assay_id int [not null, ref: > Assays.id]
    property_id int [not null, ref: > Properties.id]

    value_qualifier smallint [not null, default: 0,  note: 'SMALLINT, 0 for "=", 1 for "<", 2 for ">". Only used for numeric properties.']
    value_num float
    value_string text
    value_bool boolean


    Note: '''
    Assay results table - actual measurements: IC50, EC50, etc.
    For performance reasons, only numbers, strings, and booleans are supported for assay results (no datetime or uuid).'
    '''
}
