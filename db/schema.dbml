

Project moltrack {
    database_type: 'PostgreSQL'
    Note: 'Converted from schema.sql'
}

TablePartial created_updated_details {
    created_at timestamp [default: `CURRENT_TIMESTAMP`]
    updated_at timestamp [default: `CURRENT_TIMESTAMP`]
    created_by uuid [not null, ref: > Users.id]
    updated_by uuid [not null, ref: > Users.id]   

}

TablePartial base {
    id serial [pk]
    ~created_updated_details
}

TablePartial soft_delete_template {
    is_archived boolean [default: false]
    deleted_at timestamp [default: `CURRENT_TIMESTAMP`]
    deleted_by uuid [not null, ref: > Users.id]
}

Table moltrack.users as Users {
    id uuid [pk, not null]
    email text [not null, unique]
    first_name text [not null]
    last_name text [not null]
    has_password boolean [not null]
    is_active boolean [not null, default: false]
    is_service_account boolean [not null, default: false]
    ~created_updated_details

    indexes {
        email [unique, note: 'this may be a risk for external users over time']
    }

    Note: '''
    for MVP, just a single global user will be configured
    '''
}

Table moltrack.settings as Settings {
    id serial [pk]
    name text [not null]
    value text [not null]
    description text [not null]
 
    Note: '''
        This table is used to store configuration settings for the application.
        examples include:
        - compound standardization rules
        - compound uniqueness rules
        - compound identification rules and synonym generation rules
        - batch identification rules and synonym generation rules
        I suspect that there should be some more structure to this table, but for MVP, this will be used to store the rules for the global user.
    '''
}

Table moltrack.compounds as Compounds {
    ~base
    ~created_updated_details
    canonical_smiles text [not null, note: 'RDKit canonical SMILES']
    original_molfile text [note: 'as sketched by the chemist']
    molregno int [not null, unique, note: 'generated by the system based on business rules']
    inchi text [not null, note: 'IUPAC InChI']
    inchikey text [not null, unique, note: 'IUPAC InChIKey']
    formula text [not null]
    hash_mol uuid [not null, unique]
    hash_tautomer uuid [not null, unique]
    hash_canonical_smiles uuid [not null, unique]
    hash_no_stereo_smiles uuid [not null, unique]
    hash_no_stereo_tautomer uuid [not null, unique]
    ~soft_delete_template

    indexes {
        canonical_smiles
        inchi
        inchikey
        formula
        hash_mol [unique]
        hash_tautomer [unique]
        hash_canonical_smiles [unique]
        hash_no_stereo_smiles [unique]
        hash_no_stereo_tautomer [unique]
        molregno [unique]
    }
}

Table moltrack.batches as Batches {
    ~base
    ~created_updated_details
    compound_id int [not null, ref: > Compounds.id]
    batch_number text [not null]
    amount real
    amount_unit text
    purity real
    notes text
    expiry_date date

    indexes {
        compound_id
        batch_number
    }

    Note: '''
    need to refactor to identify what should be in details and synonyms
    I believe that amount, amount_unit, purity shoujld be properties
    '''
}

Table moltrack.additions as Additions {
    ~base
    ~created_updated_details
    name text [not null]
    description text
    display_name text
    display_order int
    is_active boolean [default: true]
    formula text
    molecular_weight real
    smiles text
    molfile text
    role text [note: "('SALT', 'SOLVATE', 'REAGENT', 'SOLVENT', 'OTHER')"]
    ~soft_delete_template

    indexes {
        name
        display_name
        display_order
        formula
        role
    }

    Note: '''
        Questions:
        - how are name, display_name, and descrition used
        - should we have UI related fields in this table, e.g., display_name, display_order
        - should we do check constraints for role?
    '''
}

Table moltrack.batch_additions as BatchAdditions {
    ~base
    ~created_updated_details
    batch_id int [not null, ref: > Batches.id]
    addition_id int [not null, ref: > Additions.id]
    addition_equivalent real [not null, default: 1.0, note: 'equivalent relative to parent batch']

    indexes {
        (batch_id, addition_id) [pk]
    }

    Note: '''
    This allows us to have multiple salt and solvates for a given batch'
    '''
}

Table moltrack.semantic_types as SemanticTypes {
    id serial [pk]
    name text [not null, note: 'e.g., "Molecule", "Cell", ...']
    description text
}

Table moltrack.properties as Properties {
    ~base
    ~created_updated_details
    name text [not null]
    value_type text [note: "('int', 'double', 'bool', 'datetime', 'string')"]
    semantic_type_id int [ref: > SemanticTypes.id]
    property_class text [note: "('CALCULATED', 'MEASURED', 'PREDICTED')"]
    unit text [note: 'future: unit should point to unit ontology']
 
    indexes {
        name
        value_type
        semantic_type_id
        property_class
    }

    Note: '''
    for validity checking should we have field to specify what entity this should be relevant
    future: property should have ontology reference
    '''
}

Table moltrack.batch_details as BatchDetails {
    id serial [pk]
    batch_id int [not null, ref: > Batches.id]
    property_id int [not null, ref: > Properties.id]

    value_datetime timestamp [note: 'with time zone', default: `CURRENT_TIMESTAMP`]
    value_uuid uuid
    value_num float
    value_string text

    indexes {
        batch_id
        property_id
    }

    Note: 'future: batch_details.value_string should have optional ontology reference'
}

Table moltrack.synonym_types as SynonymTypes {
    ~base
    ~created_updated_details
    synonym_level text [not null, note: "('BATCH','COMPOUND')"]
    name text [not null, note: 'e.g., "CAS", "USAN", "INN", "tradename"']
    pattern text [not null, note: 'regex for identifier: CHEMBL.*']
    description text [not null]

    Note: 'how to address combined uniqueness constraint'
    indexes {
        (synonym_level, name) [unique]
    }
}

Table moltrack.compound_synonyms as CompoundSynonyms {
    ~base
    ~created_updated_details
    compound_id int [not null, ref: > Compounds.id]
    synonym_type_id int [not null, ref: > SynonymTypes.id]
    synonym_value text [not null]
    
    indexes {
        compound_id
        synonym_type_id
    }
}

Table moltrack.batch_synonyms as BatchSynonyms {
    ~base
    ~created_updated_details
    batch_id int [not null, ref: > Batches.id]
    synonym_type_id int [not null, ref: > SynonymTypes.id]
    synonym_value text [not null]

    indexes {
        batch_id
        synonym_type_id
    }
}

Table moltrack.compound_details as CompoundDetails {
    id serial [pk]
    ~created_updated_details
    compound_id int [not null, ref: > Compounds.id]
    property_id int [not null, ref: > Properties.id]

    value_datetime timestamp [note: 'with time zone', default: `CURRENT_TIMESTAMP`]
    value_uuid uuid
    value_num float
    value_string text

    indexes {
        compound_id
        property_id
    }

    Note: 'future: compound_details.value_string should have optional ontology reference'
}

Table moltrack.assay_types as AssayTypes {
    id serial [pk]
    ~created_updated_details
    name text [not null]
    description text
}

Table moltrack.assay_type_details as AssayTypeDetails {
    assay_type_id int [not null, ref: > AssayTypes.id]
    property_id int [not null, ref: > Properties.id]
    required boolean [not null, default: false]

    value_datetime timestamp [note: 'timestamp with time zone']
    value_uuid uuid
    value_num float
    value_string text

    Note: 'PK: (assay_type_id, property_id)'
    indexes {
        (assay_type_id, property_id) [unique]
    }
}

Table moltrack.assays as Assays {
    id serial [pk]
    assay_type_id int [not null, ref: > AssayTypes.id]
    name text [not null, note: 'e.g., "Kinase Inhibition Assay"']
    description text
    ~created_updated_details
}

Table moltrack.assay_details as AssayDetails {
    assay_id int [not null, ref: > Assays.id]
    property_id int [not null, ref: > Properties.id]

    value_datetime timestamp [note: 'with time zone', default: `CURRENT_TIMESTAMP`]
    value_uuid uuid
    value_num float
    value_string text

    Note: 'PK: (assay_id, property_id)'
    indexes {
        (assay_id, property_id) [unique]
    }
}

Table moltrack.assay_type_properties as AssayTypeProperties {
    Note: '''
        A set of measurement types for a given assay type.
        This will be used to validate the data submitted for an assay.
    '''
    assay_type_id int [not null, ref: > AssayTypes.id]
    property_id int [not null, ref: > Properties.id]
    required bool [not null, default: false, note: 'if true, must exist in submitted data for validation']

    indexes {
        (assay_type_id, property_id) [pk]
    } 
}

Table moltrack.assay_results as AssayResults {
    id serial [pk]
    batch_id int [not null, ref: > Batches.id]
    assay_id int [not null, ref: > Assays.id]
    property_id int [not null, ref: > Properties.id]

    value_qualifier smallint [not null, default: 0,  note: 'SMALLINT, 0 for "=", 1 for "<", 2 for ">". Only used for numeric properties.']
    value_num float
    value_string text
    value_bool boolean

    indexes {
        batch_id
        assay_id
        property_id
    }

    Note: 'For performance reasons, only numbers, strings, and booleans are supported for assay results (no datetime or uuid).'

}
