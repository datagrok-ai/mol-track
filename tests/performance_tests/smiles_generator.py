from pathlib import Path
from rdkit import Chem
from rdkit.Chem import AllChem
from itertools import product
from rdkit import RDLogger
from typing import Generator


class SmilesGenerator:
    def __init__(self, data_path: Path):
        # Read rgroups_1000.smi as an array of strings into rgroups_1000
        self.load_rgroups(data_path)
        max_size = len(self.rgroups_1000) ** 3
        self.number_generated = 0
        self.core_smiles = "[*:1]n1c2cc([*:2])cc([*:3])c2cc1"  # Assymetric core
        RDLogger.logger().setLevel(RDLogger.CRITICAL)  # Suppress RDKit warnings
        self._smiles_generator = self.generate_combinatorial_library(
            core_smiles=self.core_smiles,
            rgroups1=self.rgroups_1000,
            rgroups2=self.rgroups_1000,
            rgroups3=self.rgroups_1000,
            limit=max_size,
        )

    def generate_smile(self) -> str:
        """
        Returns a random SMILES string generated by SMILESGenerator.
        """

        return next(self._smiles_generator)

    def generate_combinatorial_library(
        self, core_smiles, rgroups1, rgroups2, rgroups3, limit
    ) -> Generator[str, None, None]:
        """
        Generate a combinatorial library of SMILES strings by attaching R-groups to cores.
        """

        core = Chem.MolFromSmiles(core_smiles)
        AllChem.EmbedMolecule(core)

        # Convert R-groups to mols
        r1_mols = [Chem.MolFromSmiles(r) for r in rgroups1]
        r2_mols = [Chem.MolFromSmiles(r) for r in rgroups2]
        r3_mols = [Chem.MolFromSmiles(r) for r in rgroups3]

        for r1, r2, r3 in product(r1_mols, r2_mols, r3_mols):
            if self.number_generated >= limit:
                return
            mol = core
            # note that you need to add in reverse order of the rgroups to preserve the order of the attachment points
            mol = self.attach_rgroup(mol, r3, 2, core_fudge=0)
            mol = self.attach_rgroup(mol, r2, 1, core_fudge=0)
            mol = self.attach_rgroup(mol, r1, 0, core_fudge=-1)
            smiles = Chem.MolToSmiles(mol, canonical=True)
            self.number_generated += 1

            mol_check = Chem.MolFromSmiles(smiles)
            if mol_check is None:
                continue
            yield smiles

    def attach_rgroup(self, core_mol, rgroup, attach_idx, core_fudge: int = 0, rgroup_fudge: int = -1):
        """
        Replaces the attachment point [*] at attach_idx in core_mol with rgroup.
        Assumes both have an [*] dummy atom.
        """

        core_edit = Chem.RWMol(core_mol)
        rgroup_edit = Chem.RWMol(rgroup)

        # Get dummy atom indices
        core_dummy = [atom.GetIdx() for atom in core_edit.GetAtoms() if atom.GetAtomicNum() == 0]
        rgroup_dummy = [atom.GetIdx() for atom in rgroup_edit.GetAtoms() if atom.GetAtomicNum() == 0]

        if len(rgroup_dummy) != 1:
            raise ValueError("Each R-group must have exactly one attachment point ([*])")

        # Find the atom attached to the dummy atom in the R-group
        rgroup_attach = rgroup_edit.GetAtomWithIdx(rgroup_dummy[0]).GetNeighbors()[0].GetIdx()

        # Remove dummy atoms
        core_attach = core_dummy[attach_idx]
        core_attach_neighbors = core_edit.GetAtomWithIdx(core_attach).GetNeighbors()
        if len(core_attach_neighbors) != 1:
            raise ValueError("Core attachment point must have one neighbor")
        core_neighbor = core_attach_neighbors[0].GetIdx()

        core_edit.RemoveAtom(core_attach)
        rgroup_edit.RemoveAtom(rgroup_dummy[0])

        # Combine molecules
        combo = Chem.CombineMols(core_edit, rgroup_edit)
        combo_edit = Chem.RWMol(combo)

        # Index shift due to combining mols
        rgroup_offset = core_edit.GetNumAtoms()

        # Create bond
        combo_edit.AddBond(
            core_neighbor + core_fudge, rgroup_attach + rgroup_offset + rgroup_fudge, order=Chem.rdchem.BondType.SINGLE
        )
        return combo_edit.GetMol()

    def load_rgroups(self, data_path: Path) -> None:
        with open(data_path / "rgroups_1000.smi", "r") as f:
            self.rgroups_1000 = [line.strip() for line in f if line.strip()]
